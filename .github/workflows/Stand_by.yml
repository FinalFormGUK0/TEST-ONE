name: Stand by

on:
  workflow_dispatch:    # manual trigger

permissions:
  actions: write
  contents: read

jobs:
  standby-monitor:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout

    steps:
      - name: Monitor for Stop Signal
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          echo "üîç Starting 6-hour standby monitoring for 'Stop_rdp' command"
          echo "üì° Note: Using webhook-based detection (no polling needed)"
          
          # Function to send Telegram notification
          send_telegram_notification() {
              local message="$1"
              local max_retries=3
              local retry_count=0
              
              if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
                  echo "‚ö†Ô∏è Telegram credentials not configured, skipping notification"
                  return 1
              fi
              
              while [ $retry_count -lt $max_retries ]; do
                  echo "üì± Attempt $((retry_count + 1)): Sending Telegram notification"
                  
                  response=$(curl -s -w "%{http_code}" -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                       -d "chat_id=${TELEGRAM_CHAT_ID}" \
                       -d "text=${message}" \
                       -d "parse_mode=Markdown" \
                       -d "disable_web_page_preview=true")
                  
                  http_code="${response: -3}"
                  
                  if [ "$http_code" = "200" ]; then
                      echo "‚úÖ Telegram notification sent successfully"
                      return 0
                  else
                      echo "‚ùå Failed to send notification (HTTP: $http_code)"
                      if [ $retry_count -lt $((max_retries - 1)) ]; then
                          echo "‚è≥ Retrying in 3 seconds..."
                          sleep 3
                      fi
                  fi
                  retry_count=$((retry_count + 1))
              done
              
              echo "‚ùå Failed to send Telegram notification after $max_retries attempts"
              return 1
          }
          
          # Function to check for stop command via Telegram with improved parsing
          check_telegram_messages() {
              if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
                  echo "‚ö†Ô∏è Telegram credentials not configured, skipping telegram check"
                  return 1
              fi
              
              # Get latest messages from Telegram (last 10 messages)
              response=$(curl -s "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/getUpdates?chat_id=${TELEGRAM_CHAT_ID}&limit=10&timeout=10")
              
              # Enhanced parsing - check for various stop command formats
              if echo "$response" | grep -iE "(Stop_rdp|stop_rdp|STOP_RDP|stop rdp|Stop RDP)"; then
                  echo "üõë Stop_rdp command received via Telegram!"
                  
                  # Send acknowledgment
                  send_telegram_notification "üõë *Stop Command Received*\n\n‚úÖ Processing stop request...\nüö´ Canceling RDP session\n‚è≥ Please wait..."
                  return 0
              fi
              return 1
          }
          
          # Function to cancel RDP email workflow
          cancel_rdp_workflow() {
              echo "üö´ Attempting to cancel RDP email workflow..."
              
              # Get running RDP email workflow
              run_id=$(gh run list \
                --workflow "RDP email" \
                --repo "${{ github.repository }}" \
                --branch "${{ github.ref_name }}" \
                --status "in_progress" \
                --limit 1 \
                --json databaseId \
                --jq ".[0].databaseId")
              
              if [ "$run_id" != "null" ] && [ -n "$run_id" ]; then
                  echo "üõë Canceling RDP email run ID: $run_id"
                  if gh run cancel $run_id --repo "${{ github.repository }}"; then
                      echo "‚úÖ RDP workflow canceled successfully"
                      return 0
                  else
                      echo "‚ùå Failed to cancel RDP workflow"
                      send_telegram_notification "üö´ *RDP Cancellation Failed*\\n\\n‚ùå Failed to cancel RDP email workflow\\nüÜî Run ID: $run_id\\n\\nüîß *Action Required:* Manual intervention needed\\nüîó [Check GitHub Actions](https://github.com/${{ github.repository }}/actions/runs/$run_id)"
                      return 1
                  fi
              else
                  echo "‚ÑπÔ∏è No running RDP email workflow found to cancel"
                  send_telegram_notification "‚ÑπÔ∏è *RDP Session Status*\\n\\n‚ö†Ô∏è No active RDP session found when stop command received\\n\\nüìù *Possible reasons:*\\n‚Ä¢ Session already completed\\n‚Ä¢ Session failed to start\\n‚Ä¢ Session timed out\\n\\nüîó [Check logs](https://github.com/${{ github.repository }}/actions) for details"
                  return 1
              fi
          }
          
          # Main monitoring loop - check every 2 minutes for 6 hours (webhook will handle most cases)
          end_time=$(($(date +%s) + 21600))  # 6 hours from now
          
          while [ $(date +%s) -lt $end_time ]; do
              current_time=$(date '+%Y-%m-%d %H:%M:%S')
              echo "üíì Standby heartbeat: $current_time"
              
              # Check for stop command (backup polling - webhook is primary)
              if check_telegram_messages; then
                  echo "üõë Stop command detected via polling - canceling RDP and exiting"
                  if cancel_rdp_workflow; then
                      send_telegram_notification "‚úÖ *RDP Session Stopped*\n\n‚úÖ RDP workflow canceled successfully\n‚úÖ Session terminated by user request\n\nüìã *Summary:*\n‚Ä¢ Duration: $(($(date +%s) - $(date +%s -d "6 hours ago"))) seconds\n‚Ä¢ Status: Manually stopped\n‚Ä¢ Next: Ready for new session"
                  fi
                  
                  # Trigger Start whole WorkFlow when Stop_rdp is received
                  echo "üîÅ Triggering Start whole WorkFlow after Stop_rdp command"
                  start_workflow_run_id=$(gh run list \
                    --workflow "Start whole WorkFlow" \
                    --repo "${{ github.repository }}" \
                    --branch "${{ github.ref_name }}" \
                    --limit 1 \
                    --json databaseId \
                    --jq ".[0].databaseId")
                  
                  if [ "$start_workflow_run_id" != "null" ] && [ -n "$start_workflow_run_id" ]; then
                      echo "üîÅ Rerunning Start whole WorkFlow run ID: $start_workflow_run_id"
                      gh run rerun $start_workflow_run_id --repo "${{ github.repository }}"
                      echo "‚úÖ Start whole WorkFlow rerun triggered after Stop_rdp"
                  else
                      echo "‚ö†Ô∏è No Start whole WorkFlow found to rerun"
                  fi
                  
                  echo "üèÅ Standby monitoring stopped by user command"
                  exit 1  # Exit with failure status to prevent next step from running
              fi
              
              # Wait 2 minutes before next check (reduced from 10 minutes)
              echo "‚è≥ Waiting 2 minutes before next check..."
              sleep 120
          done
          
          echo "‚è∞ 6-hour monitoring period completed without stop command"
          send_telegram_notification "‚è∞ *RDP Session Timeout*\n\n‚ÑπÔ∏è 6-hour monitoring period completed\n‚úÖ No stop command received\nüîÑ Preparing to restart RDP session\n\nüìã *Session Summary:*\n‚Ä¢ Duration: 6 hours (full timeout)\n‚Ä¢ Status: Auto-expired\n‚Ä¢ Next: Automatic restart"

      - name: Rerun Call RDP email workflow
        if: success()  # Only run if no stop command was received
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo "üîÑ No stop command received, rerunning Call RDP email workflow"
          
          # Get the latest Call RDP email workflow run
          run_id=$(gh run list \
            --workflow "Call RDP email" \
            --repo "${{ github.repository }}" \
            --branch "${{ github.ref_name }}" \
            --limit 1 \
            --json databaseId \
            --jq ".[0].databaseId")

          if [ "$run_id" != "null" ] && [ -n "$run_id" ]; then
              echo "üîÅ Rerunning Call RDP email run ID: $run_id"
              gh run rerun $run_id --repo "${{ github.repository }}"
              echo "‚úÖ Call RDP email workflow rerun triggered"
          else
              echo "‚ùå No Call RDP email workflow found to rerun"
              exit 1
          fi
